# Haskell: infixl, infixr, infix

> https://www.haskell.org/onlinereport/decls.html#fixity

infix,infixl,infixr是Haskell中给运算符定义优先级操作用的。
例如：

```haskell
infixr 9 `op
```

infixr是右结合，infixl是左结合，infix无左右优先性。优先级一共有
十个，0-9，数字越大越高，如果定义时省略了数字，则默认为9。

预定义的优先级表格如下：

```
+----------+-----------+-----------------------------------+----------+
|          |  左结合   |              无结合               |  右结合  |
+----------+-----------+-----------------------------------+----------+
|     9    | !!        |                                   | .        |
+----------+-----------+-----------------------------------+----------+
|     8    |           |                                   | ^, ^^, **|
+----------+-----------+-----------------------------------+----------+
|     7    |*,/,`div`  |                                   |          |
+----------+-----------+-----------------------------------+----------+
|     6    |+, -       |                                   |          |
+----------+-----------+-----------------------------------+----------+
|     5    |           |                                   |:, ++     |
+----------+-----------+-----------------------------------+----------+
|     4    |           |==,/=,<,<=,>,>=,`elem`,`notElem`   |          |
+----------+-----------+-----------------------------------+----------+
|     3    |           |                                   | &&       |
+----------+-----------+-----------------------------------+----------+
|     2    |           |                                   | ||       |
+----------+-----------+-----------------------------------+----------+
|     1    | >>, >>=   |                                   |          |
+----------+-----------+-----------------------------------+----------+
|     0    |           |                                   |$,$!,`seq`|
+----------+-----------+-----------------------------------+----------+
```

根据上面的表，如果是 `1 + 2 + 3 + 4` 就等于 `((1 + 2) + 3) + 4`，因为加法
符合结合律，所以我们不容易看出来，我们来看减法。

```haskell
infixr `op`

op x y = x - y

main = do
    putStrLn $ show (5 - 3 - 2)
    putStrLn $ show (5 - 3 `op` 2)
```

```haskell
$ runhaskell tryInfix.hs 
0
4
```

上述便是效果。

Haskell中自定义的操作符非常多，往往看源代码看的眼花缭乱，此外还需要非常注意优先级。
