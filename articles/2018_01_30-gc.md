# GC 垃圾回收

涉及的技术：

- 标记-清除。第一步，从一些对象出发(这部分通常称之为root)，例如线程内的栈，将引用到的对象做标记。此后，通过第二步
清除，遍历堆中所有的数据，将没有引用的对象进行回收。

- 引用计数。对于每个对象维护一个引用计数，即自身每被引用一次，就+1，引用消失时，则-1。引用计数到0时，则为垃圾。
设定某种规则，例如垃圾数量达到多少比例之后，触发回收。

- 拷贝。把一个大的堆，把能够触及到的对象拷贝，然后把老的内存全部清理。这样做能够很好的压缩内存，避免碎片。

- 分代回收。分代回收是基于这样一个观点，新产生的对象总是很容易就被弃用。于是将对象按照年龄进行划分。

各路GC算法解决的问题：

- CPU缓存命中（如果内存分布太分散，就不能很好的利用CPU的缓存），而CPU缓存访问起来比内存快多了

- STW。为了保证GC安全，通常都是将所有执行的线程暂停，清理完之后再恢复执行。所以要遍历的对象越多，STW的时间
就越长。

- 内存碎片。对象不断的被申请和销毁。久而久之就会产生内存碎片。内存碎片影响CPU缓存，影响CPU数据对齐（不对齐的情况下
会产生更多次数的访问）。

- 吞吐量。要处理的对象/时间。

目前的GC算法都不是单纯的一种，而往往是上面多种的组合。
